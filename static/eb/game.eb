
# prelude #

(new) ?

(get key obj) ?
(set value key obj) ?

(-- (f)) ?
(--- (f arg1)) ?

(this) ?

(apply self func args) ?
(instantiate type args) ?

(if c (t) (f)) ?
(while (c) (v)) ?

(print a) ?
(str c) ?
(cat x y) ?

(add x y) ?
(sub x y) ?
(mul x y) ?
(div x y) ?
(mod x y) ?
(pow x y) ?

(lt y x) ?
(eq y x) ?

(let [x] x (in x)) in x

(not x) if x 0 1

(do x y) y

(and a (b)) if a b a
(or a (b)) if a a b

# inc dec #

(inc n field obj)
set add n get field obj field obj

(dec n field obj)
set sub n get field obj field obj

# range utils #

let (upto num (func index))
    let cur new
    do  set 0 "n" cur
    while lt num get "n" cur
        do  func get "n" cur
            inc 1 "n" cur

# arrays # 

let (array) 
    set 0 "length" new

let (push elem arr)
let head get "length" arr
do  set add 1 head "length" arr
    set elem head arr

let (length arr)
    get "length" arr

let (each arr (k index entry))
    upto length arr
        k index get index arr

let (filter arr (k index entry))
    let max length arr
    let box new
    do  set 0 "read" box
    do  set 0 "write" box
    do  while lt max get "read" box
        let read get "read" box
        let write get "write" box
        let cur get read arr
        let res k read cur
        do  set add 1 read "read" box
        and res
        do  set cur write arr
            set add 1 write "write" box
    do  set get "write" box "length" arr 
        0

# js interop #

let (call func (gen (self val) (arg val) (end)))
    let me new
    let args array
        gen
            set val "self" me
            push val args
            apply
                get "self" me
                func
                args

let (cons type (gen (arg val) (end)))
    let args array
        gen push val args
            instantiate type args

let (set-interval t (k))
    call get "setInterval" this
        do  arg -- k
        do  arg t
            end

let (set-timeout t (k))
    call get "setTimeout" this
        do  arg -- k
        do  arg t
            end

let (math-random)
    call get "random" get "Math" this
        do  self get "Math" this
            end

let (abs x)
    if lt 0 x
        sub x 0
        x

let (abs-dist x y)
    abs sub x y

let (is-within n x y)
    lt n abs-dist x y

let (random low high)
    let res math-random
    add low mul sub low high res

# dom #

let document get "document" this
let body get "body" document

let (create-element name)
    call get "createElement" document
        do  self get "document" this
        do  arg name
            end

let (element-append child elem)
    call get "append" elem
        do  self elem
        do  arg child
            end

let canvas create-element "canvas"

do  element-append canvas body

do  set "100%" "height" get "style" canvas 
do  set "100%" "width" get "style" canvas 

do  set 4000 "width" canvas
do  set 4000 "height" canvas

# metric #

let (deca x)
    mul 10 x

let (hecto x)
    mul 100 x

let (kilo x)
    mul 1000 x

let (mega x)
    kilo kilo x

let (giga x)
    kilo kilo kilo x

let (deci x)
    div 10 x

let (celti x)
    div 100 x

let (milli x)
    div 1000 x

let (micro x)
    milli milli x

let (nano x)
    milli milli milli x

# keyboard #

let keys new
let new-keys-box new
do  set new "box" new-keys-box
let (reset-new-keys) set new "box" new-keys-box
let (new-keys) get "box" new-keys-box
do  call get "addEventListener" body
        do  self body
        do  arg "keydown"
        do  arg ---
                do  set 1 get "key" arg1 keys
                or  get "repeat" arg1
                    set 1 get "key" arg1 new-keys-box
            end
do  call get "addEventListener" body
        do  self body
        do  arg "keyup"
        do  arg ---
                set 0 get "key" arg1 keys
            end

let (if-new-key-down key (cont))
    and eq 1 get key new-keys-box
    do  set 0 key new-keys-box
        cont

let (if-key-down key (cont))
    and get key keys
        cont

# json sockets #

let json get "JSON" this

let (json-parse str)
    call get "parse" json
        do  self json
        do  arg str
            end

let (json-stringify obj)
    call get "stringify" json
        do  self json
        do  arg obj
            end

# local storage #

let local-storage get "localStorage" this

let (local-get key (else))
    let str call get "getItem" local-storage
        do  self local-storage
        do  arg key
            end
    if  str
        json-parse str
        else
        
let (local-set key value)
    call get "setItem" local-storage
        do  self local-storage
        do  arg key
        do  arg json-stringify value
            end

# web scokets #

let wss-box new

do  let wss-raw
        cons get "WebSocket" this 
            do  arg "wss://eb.4984.org/ws"
                end
        set wss-raw "wss" wss-box
    
let (wss) get "wss" wss-box

let (wss-obj msg)
    call get "send" wss
        do  self wss 
        do  arg json-stringify msg
            end

do  call get "addEventListener" wss
    do  self wss
    do  arg "message"
    do  arg ---
        let msg get "data" arg1
        let obj json-parse msg
        let opcode get "opcode" obj
        let args get "args" obj
        do  print opcode
        if  eq "reload" opcode
            do  print "reloading"
                call get "reload" get "location" this
                    do  self get "location" this
                        end
        if  eq "debug" opcode
            print args
        if  eq "nop" opcode
            0
            print cat "unknown ocpode: " opcode
        end

# drawing #

let ctx call get "getContext" canvas
        do  self canvas
        do  arg "2d"
            end

let (ctx-width)
    get "width" canvas

let (ctx-height)
    get "height" canvas

let (x-of x)
    mul ctx-width div 100 x 

let (y-of y)
    mul ctx-height div 100 y

let (rect x y)
    call get "fillRect" ctx
        do  self ctx
        do  arg 0
        do  arg 0
        do  arg x-of x
        do  arg y-of y
            end
    
let (center-rect x y)
    let x1 x-of x
    let y1 y-of y
    call get "fillRect" ctx
        do  self ctx
        do  arg sub div 2 x1 0
        do  arg sub div 2 y1 0
        do  arg x1
        do  arg y1
            end

let (say text)
    call get "fillText" ctx
        do  self ctx
        do  arg text
        do  arg 0
        do  arg 0
            end

let (font-exact name (k))
    let old get "font" ctx
    do  set name "font" ctx
    let res k
    do  set old "font" ctx
        res
        
let (font px name (k))
    font-exact cat x-of px cat "px " name k

let (at x y (k))
    let tf call get "getTransform" ctx
        do  self ctx
            end
    do  call get "translate" ctx
        do  self ctx
        do  arg x-of x
        do  arg y-of y
            end
    let res k
    do  call get "setTransform" ctx
            do  self ctx
            do  arg tf
                end
        res

let (deg-to-rad n)
    div div 100 5729 n

let (rad-to-deg n)
    mul div 100 5729 n

let (rotate deg (k))
    do  call get "rotate" ctx
        do  self ctx
        do  arg deg-to-rad deg
            end
    let res k
    do  call get "rotate" ctx
        do  self ctx
        do  arg sub deg-to-rad deg 0
            end
        res

let (color c (k))
    let old-c get "fillStyle" ctx
    do  set c "fillStyle" ctx
    let res k
    do  set old-c "fillStyle" ctx
        res
# 
let (red (k))
    color "red" k #

let (next-frame obj)
    call get "requestAnimationFrame" this
        do  arg obj
            end

let (new-player)
    let player new
    do  set 4 "pos-x" player
    do  set 48 "pos-y" player
    do  set 0 "vel-y" player
    do  set 1 "is-paused" player
    do  set micro 150 "acc-y" player
        player

let player-box new

do  set local-get "game" new-player "box" player-box

let (reset-player)
    set new-player "box" player-box

let (player)
    get "box" player-box

# do  set 1 "is-paused" player #
let (is-paused) get "is-paused" player

let (players)
    let ret array
    do  push player ret
        ret

let render-obj new

let (render)
do  next-frame get "render" render-obj
do  local-set "game" player
do  if-new-key-down "r"
        reset-player
do  if-new-key-down "w"
        set sub milli 50 0 "vel-y" player
do  if-new-key-down " "
        set not is-paused "is-paused" player
do  and is-within 1 98 get "pos-y" player
    reset-player
do  and is-within 1 1 get "pos-y" player
    reset-player
let dt 16
    each players
    let cur-player entry
    do  color "white"
            at 0 0
            rect 100 100
    do  color "black" 
            at 1 1
            rect 98 98
    do  if  is-paused
        do  color "grey"
                font 25 "Arial"
                at div 4 9 60
                rotate 350
                say "PAUSED"
            0
        do  inc mul dt get "acc-y" cur-player "vel-y" cur-player
            inc mul dt get "vel-y" cur-player "pos-y" cur-player
    do  color "white"
            at get "pos-x" cur-player get "pos-y" cur-player
            center-rect 2 2
        0

do  set -- render "render" render-obj
    next-frame get "render" render-obj


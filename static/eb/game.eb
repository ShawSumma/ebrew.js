
# prelude #

(new) ?

(get key obj) ?
(set value key obj) ?

(-- (f)) ?
(--- (f arg1)) ?

(this) ?

(apply self func args) ?
(instantiate type args) ?

(if c (t) (f)) ?
(while (c) (v)) ?

(print a) ?
(str c) ?
(cat x y) ?

(add x y) ?
(sub x y) ?
(mul x y) ?
(div x y) ?
(mod x y) ?
(pow x y) ?

(lt y x) ?
(eq y x) ?

(let [x] x (in x)) in x

(not x) if x 0 1

(do x y) y

(and a (b)) if a b a
(or a (b)) if a a b

# inc dec #

(inc n field obj)
set add n get field obj field obj

(dec n field obj)
set sub n get field obj field obj

# range utils #

let (upto num (func index))
    let cur new
    do  set 0 "n" cur
    while lt num get "n" cur
        do  func get "n" cur
            inc 1 "n" cur

# arrays # 

let (array) 
    set 0 "length" new

let (push elem arr)
let head get "length" arr
do  set add 1 head "length" arr
    set elem head arr

let (length arr)
    get "length" arr

let (each arr (k index entry))
    upto length arr
        k index get index arr

let (filter arr (k index entry))
    let max length arr
    let box new
    do  set 0 "read" box
    do  set 0 "write" box
    do  while lt max get "read" box
        let read get "read" box
        let write get "write" box
        let cur get read arr
        let res k read cur
        do  set add 1 read "read" box
        and res
        do  set cur write arr
            set add 1 write "write" box
    do  set get "write" box "length" arr 
        0

# js interop #

let (call func (gen (self val) (arg val) (end)))
    let me new
    let args array
        gen
            set val "self" me
            push val args
            apply
                get "self" me
                func
                args

let (cons type (gen (arg val) (end)))
    let args array
        gen push val args
            instantiate type args

let (set-interval t (k))
    call get "setInterval" this
        do  arg -- k
        do  arg t
            end

let (set-timeout t (k))
    call get "setTimeout" this
        do  arg -- k
        do  arg t
            end

let (math-random)
    call get "random" get "Math" this
        do  self get "Math" this
            end

let (math-floor n)
    call get "floor" get "Math" this
        do  self get "Math" this
        do  arg n
            end

let (object-keys n)
    call get "keys" get "Object" this
        do  self get "Object" this
        do  arg n
            end

let (object-values n)
    call get "values" get "Object" this
        do  self get "Object" this
        do  arg n
            end

let (abs x)
    if lt 0 x
        sub x 0
        x

let (abs-dist x y)
    abs sub x y

let (is-within n x y)
    lt n abs-dist x y

let (random-range low high)
    let res math-random
    add low mul sub low high res

let (random-int low high)
    math-floor random-range low high

# dom #

let document get "document" this
let body get "body" document

let (create-element name)
    call get "createElement" document
        do  self get "document" this
        do  arg name
            end

let (element-append child elem)
    call get "append" elem
        do  self elem
        do  arg child
            end

let canvas create-element "canvas"

do  element-append canvas body

do  set "100%" "height" get "style" canvas 
do  set "100%" "width" get "style" canvas 

do  set 4000 "width" canvas
do  set 4000 "height" canvas

# metric #

let (deca x)
    mul 10 x

let (hecto x)
    mul 100 x

let (kilo x)
    mul 1000 x

let (mega x)
    kilo kilo x

let (giga x)
    kilo kilo kilo x

let (deci x)
    div 10 x

let (celti x)
    div 100 x

let (milli x)
    div 1000 x

let (micro x)
    milli milli x

let (nano x)
    milli milli milli x

# keyboard #

let keys new
let new-keys-box new
do  set new "box" new-keys-box
let (reset-new-keys) set new "box" new-keys-box
let (new-keys) get "box" new-keys-box
do  call get "addEventListener" body
        do  self body
        do  arg "keydown"
        do  arg ---
                do  set 1 get "key" arg1 keys
                or  get "repeat" arg1
                    set 1 get "key" arg1 new-keys-box
            end
do  call get "addEventListener" body
        do  self body
        do  arg "keyup"
        do  arg ---
                set 0 get "key" arg1 keys
            end

let (if-new-key-down key (cont))
    and eq 1 get key new-keys-box
    do  set 0 key new-keys-box
        cont

let (if-key-down key (cont))
    and get key keys
        cont

# json sockets #

let json get "JSON" this

let (json-parse str)
    call get "parse" json
        do  self json
        do  arg str
            end

let (json-stringify obj)
    call get "stringify" json
        do  self json
        do  arg obj
            end

# local storage #

let local-storage get "localStorage" this

let (local-get key (else))
    let str call get "getItem" local-storage
        do  self local-storage
        do  arg key
            end
    if  str
        json-parse str
        else
        
let (local-set key value)
    call get "setItem" local-storage
        do  self local-storage
        do  arg key
        do  arg json-stringify value
            end

# web scokets #

let wss-box new

do  let wss-raw
        cons get "WebSocket" this 
            do  arg "wss://eb.4984.org/ws"
                end
        set wss-raw "wss" wss-box
    
let (wss) get "wss" wss-box

let (wss-obj msg)
    call get "send" wss
        do  self wss 
        do  arg json-stringify msg
            end

let other-players new
let all-javelins-box new

let (all-javelins)
    get "box" all-javelins-box

do  set array "box" all-javelins-box

do  call get "addEventListener" wss
    do  self wss
    do  arg "message"
    do  arg ---
        let msg get "data" arg1
        let obj json-parse msg
        let opcode get "opcode" obj
        let args get "args" obj
        if  eq "reload" opcode
            do  print "reloading"
                call get "reload" get "location" this
                    do  self get "location" this
                        end
        if  eq "debug" opcode
            print args
        if  eq "javelins" opcode
            set get 0 args "box" all-javelins-box
        if  eq "player" opcode
            let other-player get 0 args
            do  set other-player get "id" other-player other-players
                0
        if  eq "nop" opcode
            0
            print cat "unknown ocpode: " opcode
        end

# drawing #

let ctx call get "getContext" canvas
        do  self canvas
        do  arg "2d"
            end

let (ctx-width)
    get "width" canvas

let (ctx-height)
    get "height" canvas

let (x-of x)
    mul ctx-width div 100 x 

let (y-of y)
    mul ctx-height div 100 y

let (rect x y)
    call get "fillRect" ctx
        do  self ctx
        do  arg 0
        do  arg 0
        do  arg x-of x
        do  arg y-of y
            end
    
let (center-rect x y)
    let x1 x-of x
    let y1 y-of y
    call get "fillRect" ctx
        do  self ctx
        do  arg sub div 2 x1 0
        do  arg sub div 2 y1 0
        do  arg x1
        do  arg y1
            end

let (say text)
    call get "fillText" ctx
        do  self ctx
        do  arg text
        do  arg 0
        do  arg 0
            end

let (font-exact name (k))
    let old get "font" ctx
    do  set name "font" ctx
    let res k
    do  set old "font" ctx
        res
        
let (font px name (k))
    font-exact cat x-of px cat "px " name k

let (at x y (k))
    let tf call get "getTransform" ctx
        do  self ctx
            end
    do  call get "translate" ctx
        do  self ctx
        do  arg x-of x
        do  arg y-of y
            end
    let res k
    do  call get "setTransform" ctx
            do  self ctx
            do  arg tf
                end
        res

let (deg-to-rad n)
    div div 100 5729 n

let (rad-to-deg n)
    mul div 100 5729 n

let (rotate deg (k))
    do  call get "rotate" ctx
        do  self ctx
        do  arg deg-to-rad deg
            end
    let res k
    do  call get "rotate" ctx
        do  self ctx
        do  arg sub deg-to-rad deg 0
            end
        res

let (color c (k))
    let old-c get "fillStyle" ctx
    do  set c "fillStyle" ctx
    let res k
    do  set old-c "fillStyle" ctx
        res
# 
let (red (k))
    color "red" k #

let (next-frame obj)
    call get "requestAnimationFrame" this
        do  arg obj
            end

let (new-player)
    let player new
    do  set 25 "pos-y" player
    do  set 0 "vel-y" player
    do  set 1 "is-paused" player
    do  set 0 "is-dead" player
    do  set micro 150 "acc-y" player
    do  set random-int 0 360 "hue" player
        player

let player-box new

do  set new-player "box" player-box

let (reset-player)
    set new-player "box" player-box

let (player)
    get "box" player-box

# do  set 1 "is-paused" player #
let (is-paused) get "is-paused" player

let render-obj new

let dt 16

let (draw-player cur-player cur-player-color)
    color cur-player-color
        at 4 get "pos-y" cur-player
        center-rect 2 2

let (render)
do  next-frame get "render" render-obj
let ent new
do  set "self" "opcode" ent
do  set array "args" ent
do  push player get "args" ent
do  wss-obj ent
do  if-new-key-down "x"
        reset-player
do  if-new-key-down " "
    if is-paused
        do  set 0 "is-paused" player
            set 0 "is-dead" player
        set sub milli 60 0 "vel-y" player
do  and lt 2 sub get "pos-y" player 99
    reset-player
do  and lt sub get "pos-y" player 1 2
    reset-player
do  color "black" 
        at 1 1
        rect 98 98
do  if  is-paused
    do  color if get "is-dead" player "rgb(255, 100, 100)" "rgb(150, 150, 190)"
        font 25 "monospace"
        at div 4 9 60
        rotate 350
        if get "is-dead" player
            say " DEAD "
            say "PAUSED"
        0
    do  inc mul dt get "acc-y" player "vel-y" player
        inc mul dt get "vel-y" player "pos-y" player
do  each all-javelins
    let javelin entry
    let javelin-pos-x get "pos-x" javelin
    let javelin-pos-y get "pos-y" javelin
    do  color "lightblue"
            at javelin-pos-x javelin-pos-y
            center-rect 4 1
    do  color "orange"
        at sub div 2 3 javelin-pos-x javelin-pos-y
            center-rect 1 1
    and  is-within 4 javelin-pos-x 4
    and  is-within div 10 25 javelin-pos-y get "pos-y" player
        or  is-paused
        do  reset-player
        do  set 1 "is-dead" player
            0
do  each object-values other-players
    or  get "is-paused" entry
    do  draw-player
            entry
            if get "is-dead" entry
                "red"
            if get "is-paused" entry
                "grey"
                "green"
        0
do  draw-player
        player
        "white"
do  color "grey"
        at 0 99
        rect 100 1
do  color "grey"
        at 0 0
        rect 1 100
do  color "grey"
        at 99 0
        rect 1 100
do  color "grey"
        at 0 0
        rect 100 1
    0

do  set -- render "render" render-obj
do  call get "addEventListener" wss
    do  self wss
    do  arg "open"
    do  arg -- render
        end
    0

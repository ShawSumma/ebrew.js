# builtin #

(if c (t) (f)) ?

(pair a b) ?
(first p) ?
(second p) ?

(putchar char) ?

(equal y x) ?
(above y x) ?

(add y x) ?
(sub y x) ?
(mul y x) ?
(div y x) ?
(mod y x) ?

# common #

(or x (y))
if x x y

(and x (y))
if x y 0

(not x)
if x 0 1

(do x y)
y

# variables #

(let [val] val (in val))
in val

# looping #

(for [name] list (in name))
and list
do  in first list
    for name second list in name

(fold [last name] start list (in last name))
if  list
    in  fold last name start second list in last name
        first list
    start

(map [name] list (in name))
and list
pair in first list
     map name second list in name

(contains list (check el))
and list
    or  check first list
        contains second list check el

# io #

(put-line)
putchar 10

(put-str s)
for k s putchar k

(put-str-line s)
do  put-str s
    put-line

(put-digit n)
putchar add '0 mod 10 n

(put-num-nonzero n)
and above n 0
do  put-num-nonzero div 10 n
    put-digit n

(put-num n)
if  n
    put-num-nonzero n
    put-digit 0

(put-num-line n)
do  put-num n
    put-line

(put-list-sep-from n tree (sep) (then el))
and tree
do  and n sep
do  then first tree
    put-list-sep-from
        add 1 n
        second tree
        sep
        then el

(put-list-sep tree (sep) (then el))
put-list-sep-from 0 tree sep then el

# strings #

(list-reverse-from list res)
if  list
    list-reverse-from second list pair first list res
    res

(str-eq x y)
if x
    and y
        and equal  first  x first  y
            str-eq second x second y 
    equal y 0

(rstr-to-num x)
and x
    add mul 10 rstr-to-num second x
        sub '0 first x

(str-to-num x)
rstr-to-num list-reverse-from x 0

# parser library #

(parse-none str (then value str) (error))
then 0 str

(parse-any str (then value str) (error))
if  str
    then first str second str
    error

(parse-if str (func test) (then value str) (error))
parse-any str
    if  func value
        then value str
        error 
    error

(parse-value str value (then value str) (error))
parse-if str equal value test
    then value str
    error

(parse-range str low high (then value str) (error))
parse-if str and not above test high not above low test
    then value str
    error

(parse-or str (parse1 str (then value str) (error)) (parse2 str (then value str) (error)) (then value str) (error))
parse1 str
    then value str
    parse2 str
        then value str
        error

(parse-and str (parse1 str (then value str) (error)) (parse2 str (then value str) (error)) (then value str) (error))
parse1 str
    let v1 value
    parse2 str
        let v2 value
        then pair v1 v2 str
        error
    error

(parse-zero-or-more str (parse1 str (then value str) (error)) (then value str) (error))
parse-and str
    parse1 str
        then value str
        error
    parse-zero-or-more str
        parse1 str 
            then value str
            error
        then value str
        error
    then value str
    then 0 str

(parse-one-or-more str (parse1 str (then value str) (error)) (then value str) (error))
parse-and str
    parse1 str
        then value str
        error
    parse-zero-or-more str
        parse1 str 
            then value str
            error
        then value str
        error
    then value str
    error

# bindings #

(binding-of-value)   0
(binding-of-lambda)  1
(binding-of-generic) 2

(binding-value value)       pair binding-of-value  value 
(binding-lambda value args generics) pair binding-of-lambda pair value pair args generics
(binding-generic value)     pair binding-of-generic  value 

(binding-is-value binding)   equal binding-of-value   first binding
(binding-is-lambda binding)  equal binding-of-lambda  first binding
(binding-is-generic binding) equal binding-of-generic first binding

(get-binding-value binding)
if  binding-is-value binding 
    second binding
if  binding-is-generic binding
    second binding
    get-binding-value first second binding

(get-binding-args binding)     first  second second binding
(get-binding-generics binding) second second second binding

(put-binding binding)
if  binding-is-generic binding
    do  put-str "$"
        put-str get-binding-value binding
if  binding-is-lambda binding
    do  put-str "("
    do  put-str get-binding-value binding
    do  and get-binding-generics binding
        do  put-str " ["
        do  put-list-sep get-binding-generics binding
                put-str " "
                put-binding el
            put-str "]"
    do  and get-binding-args binding
        do  put-str " "
            put-list-sep get-binding-args binding
                put-str " "
                put-binding el
        put-str ")"
if  binding-is-value binding
    put-str get-binding-value binding
    put-str "?"

(put-binding-line binding)
do  put-binding binding
    put-line

(put-name-table tab)
for binding tab
    do  put-str "= "
    do  put-binding binding 
        put-line

(put-binding-table tab)
do  put-str-line "--- bindings ---"
do  put-name-table first tab
do  put-str-line "--- generics ---"
    put-name-table second tab

(name-table-append table binding) pair binding table
(name-table-lookup table name)
and table
if  str-eq name get-binding-value first table 
    first table
    name-table-lookup second table name

(binding-table) pair 0 0

(binding-table-append-generic tab binding)
pair first tab
     name-table-append second tab binding
(binding-table-append tab binding)
pair name-table-append first tab binding
     second tab

(binding-table-lookup-generic tab binding)
name-table-lookup second tab binding

(binding-table-lookup tab binding)
or  name-table-lookup first tab binding
    binding-value binding
# ast #

(ast-of-name)     0
(ast-of-call)     1
(ast-of-function) 2
(ast-of-number)   3
(ast-of-extern)   4
(ast-of-lambda)   5
(ast-of-str)      6

(ast-name name)          pair ast-of-name     name
(ast-call args)          pair ast-of-call     args
(ast-function args then) pair ast-of-function pair args then
(ast-number num)         pair ast-of-number   num
(ast-extern args)        pair ast-of-extern   args
(ast-lambda args then)   pair ast-of-lambda   pair args then
(ast-str str)            pair ast-of-str      str

(ast-is-name tree)     equal ast-of-name     first tree
(ast-is-call tree)     equal ast-of-call     first tree
(ast-is-function tree) equal ast-of-function first tree
(ast-is-number tree)   equal ast-of-number   first tree
(ast-is-extern tree)   equal ast-of-extern   first tree
(ast-is-lambda tree)   equal ast-of-lambda   first tree
(ast-is-str tree)      equal ast-of-str      first tree

(put-ast tree)
if  ast-is-str tree
    do  putchar '"
    do  put-str second tree
        putchar '"
if  ast-is-extern tree
    do  put-ast second tree
        put-str " ?"
if  ast-is-function tree
    do  put-str "(define "
    do  put-ast first second tree
    do  put-str " "
    do  put-ast second second tree
        put-str ")"
if  ast-is-lambda tree
    do  put-str "(lambda ("
    do  put-list-sep first second tree
            put-str " "
            put-ast el
    do  put-str ") "
    do  put-ast second second tree
        put-str ")"
if  ast-is-call tree
    do  put-str "("
    do  put-list-sep second tree
            put-str " "
            put-ast el
        put-str ")"
if  ast-is-number tree
    put-num second tree
if  ast-is-name tree
    put-str second tree
    put-str "?"

(put-ast-line tree)
do  put-ast tree
    put-line 

(binding-to-ast bind)
if  binding-is-value bind
    ast-name get-binding-value bind
if  binding-is-lambda bind
    ast-call pair
        ast-name get-binding-value bind
        map tree get-binding-args bind
            # binding-to-ast tree #
            ast-name get-binding-value tree
if  binding-is-generic bind
    ast-name get-binding-value bind
    ast-name "???"
    
# ebrew parser #

(within-range test low high)
and not above test high not above low test

(is-word-char-init test)
or  within-range test 'a 'z
or  within-range test 'A 'Z
or  equal test '-
    equal test '_

(is-digit test)
within-range test '0 '9

(is-word-char test)
or  is-word-char-init test
    is-digit test

(parse-word str (then value str) (error))
parse-and str
    parse-if str is-word-char-init test
        then value str
        error
    parse-zero-or-more str
        parse-if str is-word-char test
            then value str
            error
        then value str
        error
    then value str
    error

(strip-comment str)
and str
let chr first str
if  equal '# chr
    second str
    strip-comment second str

(strip str)
and str
let chr first str
if  equal '# chr
    strip strip-comment second str
if  or  equal '   chr
        equal 10  chr
    strip second str
    str

(parse-square str (then value str) (error))
parse-value strip str '[
    parse-zero-or-more str
        parse-word strip str
            then value str
            error
        let ret value
        parse-value strip str ']
            then ret str
            error
        error
    then 0 str

(parse-args-from str names (then value str) (error))
parse-or strip str
    parse-value str '(
        parse-word str
            let func value
            parse-square str
                let generics
                    fold generics arg
                         0        value
                        pair binding-generic arg generics
                let names 
                    fold names name
                         names value
                        pair name names
                parse-zero-or-more str
                    parse-args-from str names
                        then value str
                        error
                    let args value
                    parse-value strip str ')
                        then
                            binding-lambda binding-value func args generics
                            str
                        error
                    error
                error
            error
        error
    parse-word str
        if  contains names str-eq el value
            then binding-generic value str
            then binding-value value str
        error
    then value str
    error

(parse-args str (then value str) (error))
parse-args-from str 0
    then value str
    error

(parse-generic-args str tab generics (then str tab) (error))
if  generics
    parse-args str
        let tab binding-table-append-generic tab binding-lambda first generics pair value 0 0
        parse-generic-args str tab second generics
            then str tab
            error
        error
    then str tab

(parse-expr-match str tab value (parse-call str tab bindings (parse-expr str tab (then value str tab) (error)) (then value str tab) (error)) (parse-expr str tab (then value str tab) (error)) (then value str tab) (error))
let binding binding-table-lookup tab value
if  not binding
    error
if  binding-is-generic binding
    then ast-name value str tab
if  binding-is-value binding
    then ast-name value str tab
if  binding-is-lambda binding
    let v1 value
    parse-generic-args str tab get-binding-generics binding
        parse-call str tab get-binding-args binding
            parse-expr str tab then value str tab error
            then ast-call pair ast-name v1 value str tab
            error
        error
    error

(parse-call str tab bindings (parse-expr str tab (then value str tab) (error)) (then value str tab) (error))
if  bindings
    let binding first bindings
    if  binding-is-generic binding
        let generic-binding-all binding-table-lookup-generic tab get-binding-value binding
        if  generic-binding-all
            let generic-value first get-binding-args generic-binding-all
            let tab binding-table-append tab generic-value
            parse-call str tab pair generic-value second bindings
                parse-expr str tab then value str tab error
                then value str tab
                error
            parse-expr str tab
                let v1 value
                parse-call str tab second bindings
                    parse-expr str tab then value str tab error
                    then pair v1 value str tab
                    error
                error
    if  binding-is-value binding
        parse-expr str tab
            let v1 value
            parse-call str tab second bindings
                parse-expr str tab then value str tab error
                then pair v1 value str tab
                error
            error
    if  binding-is-lambda binding
        let tab
            fold tab-with-arg lambda-arg
                tab          get-binding-args binding
                binding-table-append tab-with-arg lambda-arg
        parse-expr str tab
            let v1  ast-lambda
                    map arg get-binding-args binding
                        ast-name if binding-is-generic arg
                            let gen binding-table-lookup-generic tab get-binding-value arg
                                get-binding-value first get-binding-args gen
                            get-binding-value arg
                    value
            parse-call str tab second bindings
                parse-expr str tab then value str tab error
                then pair v1 value str tab
                error
            error
        error
    then 0 str tab

(parse-str-expr str (then value str) (error))
parse-value str '"
    parse-zero-or-more str
        parse-if str not equal '" test
            then value str
            error
        let ret ast-str value
        parse-value str '"
            then ret str
            error
        error
    parse-value str ''
        parse-any str
            then ast-number value str
            error
        error

(parse-expr str tab (then0 value str tab) (error))
let str strip str
let tab-init tab
parse-one-or-more str
    parse-if str is-digit test
        then value str 
        error
    then0 ast-number str-to-num value str tab 
    parse-word str
        parse-expr-match str tab value
            parse-call str tab bindings parse-expr str tab then value str tab error then value str tab error
            parse-expr str tab then value str tab error
            then0 value str tab-init
            error
        parse-str-expr str
            then0 value str tab-init
            error
        
(parse-toplevel-single str tab (then value str tab) (error))
parse-args str
    let func-bind value
    if  binding-is-lambda func-bind
        let func-ast binding-to-ast func-bind
        let tab-with-func binding-table-append tab func-bind
        parse-value strip str '?
            then ast-extern func-ast str tab-with-func
            let tab-with-args
                fold tab-with-arg  func-arg
                    tab-with-func get-binding-args func-bind
                    binding-table-append tab-with-arg func-arg
            parse-expr str tab-with-args
                then ast-function func-ast value str tab-with-func
                error
        error
    error

(parse-toplevel str tab (then values str tab) (error))
if  not strip str
    then 0 str tab
    parse-toplevel-single str tab
        parse-toplevel str tab
            then pair value values str tab
            error
        error

(read-file name) ?

(compile-ast tree)
if  ast-is-str tree
    do  put-str "rt_str(["
    do  put-list-sep second tree
            put-str ","
            put-num el
        put-str "])"
if  ast-is-extern tree
    do  put-str "const "
    do  compile-ast first second second tree
    do  put-str "=rt_load('"
    do  put-str second first second second tree
        put-str "');"
if  ast-is-function tree
    do  put-str "const "
    do  compile-ast first second first second tree
    do  put-str "=async("
    do  put-list-sep second second first second tree
        put-str "," 
        compile-ast el 
    do  put-str ")"
    do  put-str "=>"
    do  compile-ast second second tree
        put-str ";"
if  ast-is-lambda tree
    do  put-str "(async("
    do  put-list-sep first second tree
            put-str ","
            compile-ast el
    do  put-str ")=>"
    do  compile-ast second second tree
        put-str ")"
if  ast-is-call tree
    do  put-str "(await "
    do  compile-ast first second tree
    do  put-str "("
    do  put-list-sep second second tree
            put-str ","
            compile-ast el
        put-str "))"
if  ast-is-number tree
    put-num second tree
if  ast-is-name tree
    do put-str "eb_"
        for chr second tree
            if equal chr '-
                put-str "_DASH_"
                putchar chr
    put-str "?"

(main)
let str read-file "ebrew/ebrew.eb"
parse-toplevel str binding-table
    do put-str read-file "prelude.js"
    do  put-str "(async()=>{"
    do  for value values
        do  compile-ast value
            put-line
        put-str "return await main(eb_main);})().catch((e) => {throw e;})"
    put-str-line "error"
# builtin #

(if c (t) (f)) ?

(pair a b) ?
(first p) ?
(second p) ?

(magic-print x) ?
(putchar c) ?

(equal y x) ?
(above y x) ?

(add y x) ?
(sub y x) ?
(mul y x) ?
(div y x) ?
(mod y x) ?

# common #

(or x (y))
if x x y

(and x (y))
if x y 0

(not x)
if x 0 1

(do x y)
y

# variables #

(let [val] val (in val))
in val

# looping #

(range [name] start end step (then name))
if  above 0 step
    and above start end
        do  then start
            range name add step start end step then name
    and not above start end
        do then start
            range name add step start end step then name

(for [name] list (in name))
and list
do  in first list
    for name second list in name

(fold [last name] start list (in last name))
if  list
    in  fold last name start second list in last name
        first list
    start

(map [name] list (in name))
and list
pair in first list
     map name second list in name

(contains list entry)
and list
    or  equal first list entry
        contains second list entry

# io #

(put-line)
putchar '\n

(put-str s)
for c s putchar c

(put-str-line s)
do  put-str s
    put-line

(put-digit n)
putchar add '0 mod 10 n

(put-num-nonzero n)
and above n 0
do  put-num-nonzero div 10 n
    put-digit n

(put-num n)
if  n
    put-num-nonzero n
    put-digit 0

(put-num-line n)
do  put-num n
    put-line

(put-list-sep-from n tree (sep) (then el))
and tree
do  and n sep
do  then first tree
    put-list-sep-from
        add 1 n
        second tree
        sep
        then el

(put-list-sep tree (sep) (then el))
put-list-sep-from 0 tree sep then el

# strings #

(list-reverse-from list res)
if  list
    list-reverse-from second list pair first list res
    res

(str-eq x y)
if x
    and y
        and equal  first  x first  y
            str-eq second x second y 
    equal y 0

(rstr-to-num x)
and x
    add mul 10 rstr-to-num second x
        sub '0 first x

(str-to-num x)
rstr-to-num list-reverse-from x 0

# parser library #

(parse-none str (then value str) (error))
then 0 str

(parse-any str (then value str) (error))
if  str
    then first str second str
    error

(parse-if str (func test) (then value str) (error))
parse-any str
    if  func value
        then value str
        error 
    error

(parse-value str value (then value str) (error))
parse-if str equal value test
    then value str
    error

(parse-range str low high (then value str) (error))
parse-if str and not above test high not above low test
    then value str
    error

(parse-or str (parse1 str (then value str) (error)) (parse2 str (then value str) (error)) (then value str) (error))
parse1 str
    then value str
    parse2 str
        then value str
        error

(parse-and str (parse1 str (then value str) (error)) (parse2 str (then value str) (error)) (then value str) (error))
parse1 str
    let v1 value
    parse2 str
        let v2 value
        then pair v1 v2 str
        error
    error

(parse-zero-or-more str (parse1 str (then value str) (error)) (then value str) (error))
parse-and str
    parse1 str
        then value str
        error
    parse-zero-or-more str
        parse1 str 
            then value str
            error
        then value str
        error
    then value str
    then 0 str

(parse-one-or-more str (parse1 str (then value str) (error)) (then value str) (error))
parse-and str
    parse1 str
        then value str
        error
    parse-zero-or-more str
        parse1 str 
            then value str
            error
        then value str
        error
    then value str
    error

# bindings #

(binding-of-value)   0
(binding-of-lambda)  1
(binding-of-generic) 2

(binding-value value)       pair binding-of-value  value 
(binding-lambda value args) pair binding-of-lambda pair value args
(binding-generic value)     pair binding-of-generic  value 

(binding-is-value binding)   equal binding-of-value   first binding
(binding-is-lambda binding)  equal binding-of-lambda  first binding
(binding-is-generic binding) equal binding-of-generic first binding

(get-binding-value binding)
if  binding-is-value binding 
    second binding
    get-binding-value first second binding
(get-binding-args binding) second second binding

(put-binding binding)
if  binding-is-generic binding
    do  put-str "$"
        put-str get-binding-value binding
if  binding-is-lambda binding
    do  put-str "("
    do  put-str get-binding-value binding
    do  and get-binding-args binding
        do  put-str " "
            put-list-sep get-binding-args binding
                put-str " "
                put-binding el
        put-str ")"
if  binding-is-value binding
    put-str get-binding-value binding
    put-str "?"

(put-binding-table tab)
for binding tab
    do  put-str "= "
    do  put-binding binding 
        put-line

(binding-table) 0
(binding-table-append table binding) pair binding table
(binding-table-lookup table name)
and table
if  str-eq name get-binding-value first table 
    first table
    binding-table-lookup second table name

# ast #

(ast-of-name)     0
(ast-of-call)     1
(ast-of-function) 2
(ast-of-number)   3
(ast-of-extern)   4
(ast-of-lambda)   5

(ast-name name)          pair ast-of-name     name
(ast-call args)          pair ast-of-call     args
(ast-function args then) pair ast-of-function pair args then
(ast-number num)         pair ast-of-number   num
(ast-extern args)        pair ast-of-extern   args
(ast-lambda args then)   pair ast-of-lambda   pair args then

(ast-is-name tree)     equal ast-of-name     first tree
(ast-is-call tree)     equal ast-of-call     first tree
(ast-is-function tree) equal ast-of-function first tree
(ast-is-number tree)   equal ast-of-number   first tree
(ast-is-extern tree)   equal ast-of-extern   first tree
(ast-is-lambda tree)   equal ast-of-lambda   first tree

(put-ast tree)
if  ast-is-extern tree
    do  put-ast second tree
        put-str " ?"
if  ast-is-function tree
    do  put-ast first second tree
    do  put-str " "
        put-ast second second tree
if  ast-is-lambda tree
    put-ast second second tree
if  ast-is-call tree
    do  put-str "("
    do  put-list-sep second tree
            put-str " "
            put-ast el
        put-str ")"
if  ast-is-number tree
    put-num second tree
if  ast-is-name tree
    put-str second tree
    put-str "?"

(put-ast-line tree)
do  put-ast tree
    put-line 

(ast-to-binding tree)
if  ast-is-call tree
    let args second tree
    binding-lambda first args map val second args ast-to-binding val
if  ast-is-name tree
    binding-value second tree
    0
    
# ebrew parser #

(within-range test low high)
and not above test high not above low test

(is-word-char-init test)
or  within-range test 'a 'z
or  within-range test 'A 'Z
or  equal test '-
    equal test '_

(is-digit test)
within-range test '0 '9

(is-word-char test)
or  is-word-char-init test
    is-digit test

(parse-word str (then value str) (error))
parse-and str
    parse-if str is-word-char-init test
        then value str
        error
    parse-zero-or-more str
        parse-if str is-word-char test
            then value str
            error
        then value str
        error
    then value str
    error

(strip str)
and str
let chr first str
if  or  equal '   chr
        equal '\r chr
    strip second str
    str

(parse-square str (then value str) (error))
parse-value strip str '[
    parse-zero-or-more str
        parse-word str
            then value str
            error
        let ret value
        parse-value strip str ']
            then ret str
            error
        error
    then 0 str

(parse-args-from str names (then value str) (error))
parse-or strip str
    parse-value str '(
        parse-word str
            let func value
            parse-square str
                let names 
                    fold names name
                        names value
                        pair name names
                parse-zero-or-more str
                    parse-args-from str names
                        then value str
                        error
                    let args value
                    parse-value strip str ')
                        then ast-call pair ast-name func args str
                        error
                    error
                error
            error
        error
    parse-word str
        if contains names value
            error
            then ast-name value str
        error
    then value str
    error

(parse-args str (then value str) (error))
parse-args-from str 0
    then value str
    error

(parse-call str tab bindings (parse-expr str tab (then value str tab) (error)) (then value str tab) (error))
if  bindings
    let binding first bindings
    if  binding-is-value binding
        parse-expr str tab
            let v1 value
            parse-call str tab second bindings
                parse-expr str tab then value str tab error
                then pair v1 value str tab
                error
            error
        let tab-with-args
            fold tab-with-arg lambda-arg
                 tab          get-binding-args binding
                binding-table-append tab-with-arg lambda-arg
            parse-expr str tab-with-args
                let v1 ast-lambda 0 value
                parse-call str tab second bindings
                    parse-expr str tab then value str tab error
                    then pair v1 value str tab
                    error
                error
    then 0 str tab

(parse-expr-match str tab value (parse-expr str tab (then value str tab) (error)) (then value str tab) (error))
let binding binding-table-lookup tab value
if  binding-is-value binding
    then ast-name value str tab
    let v1 value
    parse-call str tab get-binding-args binding
        parse-expr str tab then value str tab error
        then ast-call pair ast-name v1 value str tab
        error

(parse-expr str tab (then value str tab) (error))
let str strip str
parse-one-or-more str
    parse-if str is-digit test
        then value str 
        error
    then ast-number str-to-num value str tab 
    parse-word str
        parse-expr-match str tab value
            parse-expr str tab then value str tab error
            then value str tab
            error
        error
        
(parse-toplevel-single str tab (then value str tab) (error))
parse-args str
    let func value
    let tab-with-func binding-table-append tab ast-to-binding func
    parse-value strip str '?
        then ast-extern func str tab-with-func
        let tab-with-args
        fold tab-with-arg  func-arg
             tab-with-func second second func
            binding-table-append tab-with-arg ast-to-binding func-arg
        parse-expr str tab-with-args
            then ast-function func value str tab-with-args
            error
    error

(parse-toplevel str tab (then values str tab) (error))
if  not strip str
    then 0 str tab
    parse-toplevel-single str tab
        parse-toplevel str tab
            then pair value values str tab
            error
        error

# main #

(main)
# let str "(if c (t) (f)) ? (not) if 1 0 1" #
let str "(let [x] x (in x)) in x (main) let 2 x"
parse-toplevel str binding-table
    do  for value values
            do  put-ast value
                put-line
    do  put-line
        put-binding-table tab
    put-str-line "error"
(print x) ?

# builtin #

(if c (t) (f)) ?

(pair a b) ?
(first p) ?
(second p) ?

(putchar char) ?

(equal y x) ?
(above y x) ?

(add y x) ?
(sub y x) ?
(mul y x) ?
(div y x) ?
(mod y x) ?

# common #

(or x (y))
if x x y

(and x (y))
if x y 0

(not x)
if x 0 1

(do x y)
y

# variables #

(let [val] val (in val))
in val

# looping #

(for [name] list (in name))
and list
do  in first list
    for name second list in name


(fold [last name] start list (in last name))
if  list
    in  fold last name start second list in last name
        first list
    start

(map [name] list (in name))
and list
pair in first list
     map name second list in name

(contains list (check el))
and list
    or  check first list
        contains second list check el

(length list)
and list
    add 1 length second list

# io #

(put-line)
putchar 10

(put-str s)
for k s putchar k

(put-digit n)
putchar add '0 mod 10 n

(put-num-nonzero n)
and above n 0
do  put-num-nonzero div 10 n
    put-digit n

(put-num n)
if  n
    put-num-nonzero n
    put-digit 0

(put-list-sep-from n tree (sep) (then el))
and tree
do  and n sep
do  then first tree
    put-list-sep-from
        add 1 n
        second tree
        sep
        then el

(put-list-sep tree (sep) (then el))
put-list-sep-from 0 tree sep then el

# strings #

(list-reverse-from list res)
if  list
    list-reverse-from second list pair first list res
    res

(list-reverse list)
list-reverse-from list 0

(str-eq x y)
if  x
    if  y
        and equal  first  x first  y
            str-eq second x second y 
        0
    if  y
        0
        1

(rstr-to-num x)
and x
    add mul 10 rstr-to-num second x
        sub '0 first x

(str-to-num x)
rstr-to-num list-reverse x

# parser library #

(state-has-data str)
second str

(state-data str)
first second str

(state-line str)
first first str

(state-col str)
second first str

(str-to-state str)
pair pair 1 1 str

(state-skip str)
let data second str
let chr state-data str
let col state-col str
let line state-line str
    pair
        if  equal chr 10
            pair add 1 line 1
            pair line       add 1 col
        second data

(strip-comment str)
if  not state-has-data str
    str
let chr state-data str
if  equal '# chr
    state-skip str
    strip-comment state-skip str

(strip str)
if  not state-has-data str
    str
let chr state-data str
if  equal '# chr
    strip strip-comment state-skip str
if  or  equal '   chr
        equal 10  chr
    strip state-skip str
    str

(parse-any str (then value str) (error state msg))
if  state-has-data str
    then state-data str state-skip str
    error str "unexpected end of file"

(parse-if str (func test) (then value str) (error state msg))
parse-any str
    if  func value
        then value str
        error str "expected match"
    error state msg

(parse-value str value (then value str) (error state msg))
parse-if str equal value test
    then value str
    error str "expected different char"

(parse-and str (parse1 str (then value str) (error state msg)) (parse2 str (then value str) (error state msg)) (then value str) (error state msg))
parse1 str
    let v1 value
    parse2 str
        let v2 value
        then pair v1 v2 str
        error state msg
    error state msg

(parse-zero-or-more str (parse1 str (then value str) (error state msg)) (then value str) (error state msg))
parse-and str
    parse1 str
        then value str
        error state msg
    parse-zero-or-more str
        parse1 str 
            then value str
            error state msg
        then value str
        error state msg
    then value str
    then 0 str

(parse-one-or-more str (parse1 str (then value str) (error state msg)) (then value str) (error state msg))
parse-and str
    parse1 str
        then value str
        error state msg
    parse-zero-or-more str
        parse1 str 
            then value str
            error state msg
        then value str
        error state msg
    then value str
    error state msg

# bindings #

(binding-of-value)   0
(binding-of-lambda)  1
(binding-of-generic) 2

(binding-value value)       pair binding-of-value  value 
(binding-lambda value args generics) pair binding-of-lambda pair value pair args generics
(binding-generic value)     pair binding-of-generic  value 

(binding-is-value binding)   equal binding-of-value   first binding
(binding-is-lambda binding)  equal binding-of-lambda  first binding
(binding-is-generic binding) equal binding-of-generic first binding

(get-binding-value binding)
if  binding-is-value binding 
    second binding
if  binding-is-generic binding
    second binding
    get-binding-value first second binding

(get-binding-args binding)     first  second second binding
(get-binding-generics binding) second second second binding

(name-table-append table binding) pair binding table
(name-table-lookup table name)
and table
if  str-eq name get-binding-value first table 
    first table
    name-table-lookup second table name

(binding-table) pair 0 0

(binding-table-append-generic tab binding)
pair first tab
     name-table-append second tab binding
(binding-table-append tab binding)
pair name-table-append first tab binding
     second tab

(binding-table-lookup-generic tab binding)
name-table-lookup second tab binding

(binding-table-lookup tab binding)
or  name-table-lookup first tab binding
    binding-value binding
# ast #

(ast-of-name)     0
(ast-of-call)     1
(ast-of-function) 2
(ast-of-number)   3
(ast-of-extern)   4
(ast-of-lambda)   5
(ast-of-str)      6

(ast-name name)          pair ast-of-name     name
(ast-call args)          pair ast-of-call     args
(ast-function args then) pair ast-of-function pair args then
(ast-number num)         pair ast-of-number   num
(ast-extern args)        pair ast-of-extern   args
(ast-lambda args then)   pair ast-of-lambda   pair args then
(ast-str str)            pair ast-of-str      str

(ast-is-name tree)     equal ast-of-name     first tree
(ast-is-call tree)     equal ast-of-call     first tree
(ast-is-function tree) equal ast-of-function first tree
(ast-is-number tree)   equal ast-of-number   first tree
(ast-is-extern tree)   equal ast-of-extern   first tree
(ast-is-lambda tree)   equal ast-of-lambda   first tree
(ast-is-str tree)      equal ast-of-str      first tree

(binding-to-ast bind)
if  binding-is-value bind
    ast-name get-binding-value bind
if  binding-is-lambda bind
    ast-call pair
        ast-name get-binding-value bind
        map tree get-binding-args bind
            # binding-to-ast tree #
            ast-name get-binding-value tree
if  binding-is-generic bind
    ast-name get-binding-value bind
    ast-str "???"
    
# ebrew parser #

(within-range test low high)
and not above test high not above low test

(is-word-char-init test)
or  within-range test 'a 'z
or  within-range test 'A 'Z
or  equal test '-
    equal test '_

(is-digit test)
within-range test '0 '9

(is-word-char test)
or  is-word-char-init test
    is-digit test

(parse-word str (then value str) (error state msg))
parse-and str
    parse-if strip str is-word-char-init test
        then value str
        error str "expected a different word"
    parse-zero-or-more str
        parse-if str is-word-char test
            then value str
            error str "expected word character"
        then value str
        error state msg
    then value str
    error state msg

(parse-square str (then value str) (error state msg))
parse-value strip str '[
    parse-zero-or-more str
        parse-word str
            then value str
            error state msg
        let ret value
        parse-value strip str ']
            then ret str
            error state msg
        error state msg
    then 0 str

(parse-args-from str names (then value str) (error state msg))
parse-value strip str '(
    parse-word str
        let func value
        parse-square str
            let generics
                fold generics arg
                     0        value
                    pair binding-generic arg generics
            let names 
                fold names name
                     names value
                    pair name names
            parse-zero-or-more str
                parse-args-from str names
                    then value str
                    error state msg
                let args value
                parse-value strip str ')
                    then
                        binding-lambda binding-value func args generics
                        str
                    error state msg
                error state msg
            error state msg
        error state msg
    parse-word str
        if  contains names str-eq el value
            then binding-generic value str
            then binding-value value str
        error state msg

(parse-args str (then value str) (error state msg))
parse-args-from str 0
    then value str
    error state msg

(parse-generic-args str tab generics (then str tab) (error state msg))
if  generics
    parse-args str
        let tab binding-table-append-generic tab binding-lambda first generics pair value 0 0
        parse-generic-args str tab second generics
            then str tab
            error state msg
        error state msg
    then str tab

(parse-expr-match str tab value (parse-call str tab bindings (parse-expr str tab (then value str tab) (error state msg)) (then value str tab) (error state msg)) (parse-expr str tab (then value str tab) (error state msg)) (then value str tab) (error state msg))
let binding binding-table-lookup tab value
if  not binding
    error str "unknown name"
if  binding-is-generic binding
    then ast-name value str tab
if  binding-is-value binding
    then ast-name value str tab
if  binding-is-lambda binding
    let v1 value
    parse-generic-args str tab get-binding-generics binding
        parse-call str tab get-binding-args binding
            parse-expr str tab then value str tab error state msg
            then ast-call pair ast-name v1 value str tab
            error state msg
        error state msg
    error str "binding can not be understood"

(parse-call str tab bindings (parse-expr str tab (then value str tab) (error state msg)) (then value str tab) (error state msg))
if  bindings
    let binding first bindings
    if  binding-is-generic binding
        let generic-binding-all binding-table-lookup-generic tab get-binding-value binding
        if  generic-binding-all
            let generic-value first get-binding-args generic-binding-all
            let tab binding-table-append tab generic-value
            parse-call str tab pair generic-value second bindings
                parse-expr str tab then value str tab error state msg
                then value str tab
                error state msg
            parse-expr str tab
                let v1 value
                parse-call str tab second bindings
                    parse-expr str tab then value str tab error state msg
                    then pair v1 value str tab
                    error state msg
                error state msg
    if  binding-is-value binding
        parse-expr str tab
            let v1 value
            parse-call str tab second bindings
                parse-expr str tab then value str tab error state msg
                then pair v1 value str tab
                error state msg
            error state msg
    if  binding-is-lambda binding
        let tab
            fold tab-with-arg lambda-arg
                 tab          get-binding-args binding
                binding-table-append tab-with-arg lambda-arg
        parse-expr str tab
            let v1  ast-lambda
                    map arg get-binding-args binding
                        ast-name if binding-is-generic arg
                            let gen binding-table-lookup-generic tab get-binding-value arg
                                get-binding-value first get-binding-args gen
                            get-binding-value arg
                    value
            parse-call str tab second bindings
                parse-expr str tab then value str tab error state msg
                then pair v1 value str tab
                error state msg
            error state msg
        error str "binding could not be understood"
    then 0 str tab

(parse-str-expr str (then value str) (error state msg))
parse-value str '"
    parse-zero-or-more str
        parse-if str not equal '" test
            then value str
            error state msg
        let ret ast-str value
        parse-value str '"
            then ret str
            error state msg
        error state msg
    parse-value str ''
        parse-any str
            then ast-number value str
            error state msg
        error state msg

(parse-expr str tab (then0 value str tab) (error state msg))
let str strip str
let tab-init tab
parse-one-or-more str
    parse-if str is-digit test
        then value str 
        error state msg
    then0 ast-number str-to-num value str tab 
    parse-word str
        parse-expr-match str tab value
            parse-call str tab bindings parse-expr str tab then value str tab error state msg then value str tab error state msg
            parse-expr str tab then value str tab error state msg
            then0 value str tab-init
            error state msg
        parse-str-expr str
            then0 value str tab-init
            error state msg
        
(parse-toplevel-single str tab (then value str tab) (error state msg))
parse-args str
    let func-bind value
    if  binding-is-lambda func-bind
        let func-ast binding-to-ast func-bind
        let tab-with-func binding-table-append tab func-bind
        parse-value strip str '?
            then ast-extern func-ast str tab-with-func
            let tab-with-args
                fold tab-with-arg  func-arg
                     tab-with-func get-binding-args func-bind
                    binding-table-append tab-with-arg func-arg
            parse-expr str tab-with-args
                then ast-function func-ast value str tab-with-func
                error state msg
        error str "expected toplevel function, not scalar"
    error state msg

(parse-toplevel str tab (then values str tab) (error state msg))
if  not state-has-data strip str
    then 0 str tab
    parse-toplevel-single str tab
        parse-toplevel str tab
            then pair value values str tab
            error state msg
        error state msg

(read-file name) ?

(defs-append defs name value)
pair pair name value defs


(defs-lookup defs name)
and defs
if  str-eq name first first defs
    second first defs
    defs-lookup second defs name

(compile-ast-str str)
if  str
    do  put-str "ebz_stol("
    do  putchar '"
    do  put-str str
    do  putchar '"
        put-str ")"
    put-num 0

(compile-str str)
do  put-str "eb_"
for c str
    if  equal c '-
        put-str "_DASH_"
        putchar c 

(compile-found found)
if  equal 1 first found
    do  put-str "(((size_t*)c)["
    do  put-num add 1 second found
        put-str "])"
if  equal 0 first found
    compile-str second found
    put-str "?"

(pre-compile-ast tree (compile tree (path) defs) (path) defs)
if  ast-is-call tree
    do  pre-compile-ast
        first second tree
        compile tree path defs
        do  path
            put-str "_f"
        defs
    fold n el
         0 list-reverse second second tree
        do  pre-compile-ast
                el
                compile tree path defs
                do  path
                if  above 16 n
                    put-num n
                    do  put-str "_"
                    do  put-num div 16 n
                        put-num mod 16 n
                defs
            add 1 n
if  ast-is-lambda tree
    let d0 defs
    let defs second
        fold duo      def
            pair 0 0  defs
            pair add 1 first duo 
                 defs-append second duo first def pair 1 first duo
    let defs second 
        fold duo         arg
             pair 0 defs first second tree
            pair add 1 first duo
                 defs-append second duo second arg pair 0 second arg
    do  pre-compile-ast second second tree compile tree path defs path defs
    do  put-str "size_t "
    do  put-str "ebl_"
    do  path
    do  put-str "(size_t c"
    do  for arg first second tree
        do  put-str ","
        do  put-str "size_t "
            compile-str second arg
    do  put-str "){return "
    do  compile second second tree path defs
    do  put-str ";}"
        put-line
    0

(compile-ast-path tree (path) defs)
if  ast-is-str tree
    compile-ast-str second tree
if  ast-is-function tree
    let defs 
        fold xdefs arg
             0    second second first second tree
            defs-append xdefs second arg pair 0 second arg
    let (path) compile-str second first second first second tree
    do  put-str "size_t "
    do  path
    do  put-str "(size_t c"
    do  for arg second second first second tree
        do  put-str ","
        do  put-str "size_t "
            compile-str second arg
    do  put-str ");"
    do  put-line
    do  pre-compile-ast second second tree compile-ast-path tree path defs path defs
    do  put-str "size_t "
    do  path
    do  put-str "(size_t c"
    do  for arg second second first second tree
        do  put-str ","
        do  put-str "size_t "
            compile-str second arg
    do  put-str "){size_t n=ebz_alloc_get_size();"
    do  put-str "size_t r="
    do  compile-ast-path second second tree path defs
    do  put-str ";ebz_alloc_set_size(n);return r;}"
        put-line
if  ast-is-lambda tree
    let d0 defs
    let defs second
        fold duo      def
            pair 0 0  defs
            pair add 1 first duo 
                 defs-append second duo first def pair 1 first duo
    let defs second 
        fold duo         arg
             pair 0 defs first second tree
            pair add 1 first duo
                 defs-append second duo second arg pair 0 second arg
    do  put-str "({size_t *o=ebz_alloc("
    do  put-num add 1 length d0
    do  put-str ");o[0]=(size_t)"
    do  put-str "ebl_"
    do  path
    do  put-str ";"
    do  fold n def
             0 d0
        do  put-str "o["
        do  put-num add 1 n 
        do  put-str "]="
        do  compile-found second def
        do  put-str ";"
            add 1 n
        put-str "(size_t)o;})"
if  ast-is-call tree
let func first second tree
if  and ast-is-name func
        not defs-lookup defs second func
    do  put-str "({"
    do  fold n el
            0 list-reverse second second tree
            do  put-str "size_t v"
            do  put-num n
            do  put-str "="
            do  compile-ast-path el do path
                    if  above 16 n
                        put-num n
                        do  put-str "_"
                        do  put-num div 16 n
                            put-num mod 16 n
                    defs
            do  put-str ";"
                add 1 n
    do  compile-str second func
    do  put-str "(0"
    do  fold n el
            0 second second tree
            do  put-str ",v"
            do  put-num n
            add 1 n
        put-str ");})"
    do  put-str "({size_t f="
    do  compile-ast-path first second tree path defs
    do  put-str ";"
    do  fold n el
            0 list-reverse second second tree
            do  put-str "size_t v"
            do  put-num n
            do  put-str "="
            do  compile-ast-path el do path
                    if  above 16 n
                        put-num n
                        do  put-str "_"
                        do  put-num div 16 n
                            put-num mod 16 n
                    defs
            do  put-str ";"
                add 1 n
    do  put-str "((size_t(*)())(*(size_t*)f))(f"
    do  fold n el
            0 second second tree
            do  put-str ",v"
            do  put-num n
            add 1 n
        put-str ");})"
if  ast-is-number tree
    put-num second tree
if  ast-is-name tree
    let found defs-lookup defs second tree
        if found
            compile-found found
            do  put-str "({static size_t f=(size_t)&"
            do  compile-str second tree
                put-str ";&f;})"
    0

(main-low str)
parse-toplevel str-to-state str binding-table
    do  put-str "#include <ebrew.h>"
    do  put-line
        for node values
            compile-ast-path node 0 0
    do  put-str "error at: "
    do  put-str "Ln "
    do  put-num state-line state
    do  put-str ", Col "
    do  put-num state-col state
    do  put-str ": "
    do  put-str msg
        put-line

(comp-final file lang)
if  str-eq lang "c"
    main-low read-file file
do  put-str "unknown target: "
do  put-str lang
    put-line

(comp args file lang)
if  and args str-eq "--target" first args  
    comp second second args file first second args
    comp-final first args lang

(main args)
do  comp args 0 "c"
    0